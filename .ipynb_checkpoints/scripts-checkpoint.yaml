primary_script: |
  () => {
    'use strict';
    
    // Function to parse Russian time labels to YYYY-MM-DD HH:MM:SS format
    function parseTimeLabel(timeLabel) {
        if (!timeLabel) return null;
        
        const now = new Date();
        const months = {
            'янв': 0, 'фев': 1, 'мар': 2, 'апр': 3, 'май': 4, 'июн': 5,
            'июл': 6, 'авг': 7, 'сен': 8, 'окт': 9, 'ноя': 10, 'дек': 11
        };
        
        // Helper function to format date
        const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = '00';
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        };
        
        try {
            // Pattern 1: "сегодня, HH:MM"
            if (timeLabel.includes('сегодня')) {
                const match = timeLabel.match(/(\d{1,2}):(\d{2})/);
                if (match) {
                    const result = new Date(now);
                    result.setHours(parseInt(match[1]), parseInt(match[2]), 0, 0);
                    return formatDate(result);
                }
            }
            
            // Pattern 2: "вчера, HH:MM"
            else if (timeLabel.includes('вчера')) {
                const match = timeLabel.match(/(\d{1,2}):(\d{2})/);
                if (match) {
                    const result = new Date(now);
                    result.setDate(result.getDate() - 1);
                    result.setHours(parseInt(match[1]), parseInt(match[2]), 0, 0);
                    return formatDate(result);
                }
            }
            
            // Pattern 3: "DD месяц, HH:MM"
            else {
                // More flexible regex to handle various spacing
                const match = timeLabel.match(/(\d{1,2})\s+([а-яА-Я]+),?\s+(\d{1,2}):(\d{2})/);
                if (match) {
                    const day = parseInt(match[1]);
                    const monthName = match[2].toLowerCase();
                    const hour = parseInt(match[3]);
                    const minute = parseInt(match[4]);
                    
                    if (monthName in months) {
                        const month = months[monthName];
                        let year = now.getFullYear();
                        
                        const result = new Date(year, month, day, hour, minute, 0);
                        
                        // If date is in future, it's from last year
                        if (result > now) {
                            result.setFullYear(year - 1);
                        }
                        
                        return formatDate(result);
                    }
                }
            }
        } catch (e) {
            console.error('Error parsing time label:', e);
        }
        
        return timeLabel; // Return original if parsing fails
    }
    
    // Function to replace -4.jpg with -1.jpg in image URLs
    function fixImageUrl(url) {
        if (url && url.endsWith('-4.jpg')) {
            return url.replace(/-4\.jpg$/, '-1.jpg');
        }
        return url;
    }
    
    // Function to extract URLs, prices, images, and time labels from CardComponent elements within Offers container
    function extractCardData() {
        const cardComponents = document.querySelectorAll('[data-name="Offers"] [data-name="CardComponent"]');
        const results = [];
        
        cardComponents.forEach((card, index) => {
            // Look for the link within each card
            const link = card.querySelector('a[href*="/rent/flat/"]');
            
            if (link) {
                const url = link.href;
                
                // Extract offer_id from URL
                const match = url.match(/\/rent\/flat\/(\d+)\//);
                const offerId = match ? match[1] : null;
                
                // Look for price within the card
                const priceElement = card.querySelector('[data-mark="MainPrice"] span');
                let price = null;
                
                if (priceElement) {
                    // Extract price text and clean it
                    const priceText = priceElement.textContent.trim();
                    // Remove currency symbol and "/мес." and convert to number
                    price = priceText.replace(/[^\d]/g, '');
                    price = price ? parseInt(price) : null;
                }
                
                // Extract image URLs from gallery
                const imageUrls = [];
                const galleryElement = card.querySelector('[data-name="Gallery"]');
                if (galleryElement) {
                    const images = galleryElement.querySelectorAll('img');
                    images.forEach(img => {
                        if (img.src && img.src.includes('images.cdn-cian.ru')) {
                            // Fix image URL if needed
                            const imageUrl = fixImageUrl(img.src);
                            imageUrls.push(imageUrl);
                        }
                    });
                }
                
                // Extract time label - only absolute time
                let timeLabel = null;
                const timeLabelElement = card.querySelector('[data-name="TimeLabel"]');
                if (timeLabelElement) {
                    // Look for the absolute time in the specific div
                    const absoluteTimeDiv = timeLabelElement.querySelector('._93444fe79c--absolute--yut0v');
                    if (absoluteTimeDiv) {
                        const timeSpan = absoluteTimeDiv.querySelector('span');
                        if (timeSpan) {
                            const rawTimeLabel = timeSpan.textContent.trim();
                            // Convert Russian time label to YYYY-MM-DD HH:MM:SS format
                            timeLabel = parseTimeLabel(rawTimeLabel);
                        }
                    }
                }
                
                // Extract title
                let title = null;
                let floor = null;
                let totalFloors = null;
                
                const titleElement = card.querySelector('[data-mark="OfferTitle"]');
                if (titleElement) {
                    const titleSpan = titleElement.querySelector('span');
                    if (titleSpan) {
                        title = titleSpan.textContent.trim();
                        
                        // Extract floor and total_floors from title
                        // Pattern: *, *, {floor}/{total_floors} этаж
                        const floorMatch = title.match(/(\d+)\/(\d+)\s*этаж/);
                        if (floorMatch) {
                            floor = parseInt(floorMatch[1]);
                            totalFloors = parseInt(floorMatch[2]);
                        }
                    }
                }
                
                if (offerId) {
                    results.push({
                        offer_id: offerId,
                        offer_url: url,
                        price: price,
                        image_urls: imageUrls,
                        time_label: timeLabel,
                        title: title,
                        floor: floor,
                        total_floors: totalFloors
                    });
                }
            }
        });
        
        return results;
    }
    
    // Return array of objects with offer_id, offer_url, price, image_urls, and time_label
    return extractCardData();
  }
wait_for_function: |
  () => {
      // Wait for card components within Offers container to load
      const cardsLoaded = document.querySelectorAll('[data-name="Offers"] [data-name="CardComponent"]').length > 0;
      return cardsLoaded;
  }
